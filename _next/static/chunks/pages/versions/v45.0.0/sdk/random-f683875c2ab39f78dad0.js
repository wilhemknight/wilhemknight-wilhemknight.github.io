_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[1492],{k3AO:function(e,t,n){"use strict";n.r(t),n.d(t,"meta",(function(){return m})),n.d(t,"headings",(function(){return s})),n.d(t,"default",(function(){return l}));var o=n("HALo"),a=n("dhJC"),r=(n("q1tI"),n("7ljp")),i=n("3Ukx"),p=n("HCau"),c=n("hykZ"),d=["components"],m={title:"Random",sourceCodeUrl:"https://github.com/expo/expo/tree/sdk-45/packages/expo-random",packageName:"expo-random"},s=[{depth:2,type:"text",title:"Installation"},{depth:2,type:"text",title:"API"}],b={meta:m,headings:s};function l(e){var t=e.components,n=Object(a.a)(e,d);return Object(r.b)("wrapper",Object(o.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"expo-random")," provides a native interface for creating strong random bytes. With ",Object(r.b)("inlineCode",{parentName:"p"},"Random")," you can create values equivalent to Node.js core ",Object(r.b)("inlineCode",{parentName:"p"},"crypto.randomBytes")," API. ",Object(r.b)("inlineCode",{parentName:"p"},"expo-random")," also works with ",Object(r.b)("inlineCode",{parentName:"p"},"expo-standard-web-crypto"),", which implements the W3C Crypto API for generating random bytes."),Object(r.b)(c.a,{android:!0,emulator:!0,ios:!0,simulator:!0,web:!0,mdxType:"PlatformsSection"}),Object(r.b)("h2",{id:"installation"},"Installation"),Object(r.b)(p.a,{mdxType:"APIInstallSection"}),Object(r.b)("h2",{id:"api"},"API"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import * as Random from 'expo-random';\n")),Object(r.b)(i.a,{packageName:"expo-random",apiName:"Random",mdxType:"APISection"}))}l.isMDXComponent=!0},ocix:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/versions/v45.0.0/sdk/random",function(){return n("k3AO")}])}},[["ocix",1,0,2,3,4,5,6,7,8,9,10,11,12,13,14]]]);