_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[122],{"0L4s":function(e,t,n){"use strict";n.r(t),n.d(t,"meta",(function(){return s})),n.d(t,"headings",(function(){return l})),n.d(t,"default",(function(){return u}));var i=n("HALo"),a=n("dhJC"),r=(n("q1tI"),n("7ljp")),o=n("KiYJ"),p=["components"],s={title:"Runtime versions and updates"},l=[{depth:2,type:"inlineCode",title:'Setting  "runtimeVersion"'},{depth:3,type:"inlineCode",title:'"sdkVersion"  runtime version policy'},{depth:3,type:"inlineCode",title:'"nativeVersion"  runtime version policy'},{depth:3,type:"inlineCode",title:'Custom  "runtimeVersion"'},{depth:3,type:"inlineCode",title:'Platform specific  "runtimeVersion"'},{depth:2,type:"text",title:"Avoiding crashes with incompatible updates"}],c={meta:s,headings:l};function u(e){var t=e.components,n=Object(a.a)(e,p);return Object(r.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Runtime versions are a property that guarantees compatibility between a build's native code and an update. When a project is made into a build, the build will contain some native code that cannot be changed with an update. Therefore, an update must be compatible with a build's native code to run on the build."),Object(r.b)("p",null,"To illustrate how builds and updates interact, take a look at the following diagram:"),Object(r.b)(o.a,{alt:"Native and update layers diagram",src:"/static/images/eas-update/layers.png",mdxType:"ImageSpotlight"}),Object(r.b)("p",null,"Builds can be thought of as two layers: a native layer that's built into the app's binary, and an update layer, that is swappable with other compatible updates. This separation allows us to ship bug fixes to builds as long as the update with the bug fix can run on the native layer inside the build. The ",Object(r.b)("inlineCode",{parentName:"p"},'"runtimeVersion"')," property allows us to guarantee that an update is compatible with a specific build's native code."),Object(r.b)("p",null,"Since updates must be compatible with a build's native code, any time native code is updated, we're required to make a new build before publishing an update. Some developers only update native code when upgrading to a new Expo SDK, while others may upgrade native code between builds or at other intervals. Below is an explanation of different situations and configurations that may suite your project."),Object(r.b)("h2",{id:"setting-runtimeversion"},"Setting ",Object(r.b)("inlineCode",{parentName:"h2"},'"runtimeVersion"')),Object(r.b)("p",null,"To make managing the ",Object(r.b)("inlineCode",{parentName:"p"},'"runtimeVersion"')," property easier between builds and updates, we've created runtime version policies that will update automatically based on other fields inside the app config (",Object(r.b)("strong",{parentName:"p"},"app.json"),"/",Object(r.b)("strong",{parentName:"p"},"app.config.js"),"). If these policies do not match the development flow of a project, there's also an option to set the ",Object(r.b)("inlineCode",{parentName:"p"},'"runtimeVersion"')," manually."),Object(r.b)("h3",{id:"sdkversion-runtime-version-policy"},Object(r.b)("inlineCode",{parentName:"h3"},'"sdkVersion"')," runtime version policy"),Object(r.b)("p",null,"By default, we provide the ",Object(r.b)("inlineCode",{parentName:"p"},'"sdkVersion"')," runtime version policy after running ",Object(r.b)("inlineCode",{parentName:"p"},"eas update:configure"),":"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "expo": {\n    "runtimeVersion": {\n      "policy": "sdkVersion"\n    }\n  }\n}\n')),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},'"sdkVersion"')," policy will set the runtime version to the current SDK version of a project. For instance, if the project is on Expo SDK 1.0.0, the runtime version with this policy will be ",Object(r.b)("inlineCode",{parentName:"p"},'"exposdk:1.0.0"'),". This runtime version will update any time we update the project's Expo SDK. So, if we ran ",Object(r.b)("inlineCode",{parentName:"p"},"expo upgrade")," and installed Expo SDK 2.0.0, then the runtime version would become ",Object(r.b)("inlineCode",{parentName:"p"},'"exposdk:2.0.0"'),"."),Object(r.b)("p",null,"This runtime version policy is perfect if you are not including custom native code in your project and the only native changes you make are when upgrading Expo SDKs."),Object(r.b)("h3",{id:"nativeversion-runtime-version-policy"},Object(r.b)("inlineCode",{parentName:"h3"},'"nativeVersion"')," runtime version policy"),Object(r.b)("p",null,"We provide the ",Object(r.b)("inlineCode",{parentName:"p"},'"nativeVersion"')," runtime version policy for projects that have custom native code that may change between builds:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "expo": {\n    "runtimeVersion": {\n      "policy": "nativeVersion"\n    }\n  }\n}\n')),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},'"nativeVersion"')," policy will set the runtime version to the projects current ",Object(r.b)("inlineCode",{parentName:"p"},'"version"')," and ",Object(r.b)("inlineCode",{parentName:"p"},'"buildNumber"')," (iOS) or ",Object(r.b)("inlineCode",{parentName:"p"},'"versionCode"')," (Android) properties. For a project that has the following in its app config:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "expo": {\n    "runtimeVersion": {\n      "policy": "nativeVersion"\n    },\n    "version": "1.0.0",\n    "ios": {\n      "buildNumber": "1"\n    },\n    "android": {\n      "versionCode": 1\n    }\n  }\n}\n')),Object(r.b)("p",null,"The runtime version for the iOS and Android builds and any updates would be the combination of ",Object(r.b)("inlineCode",{parentName:"p"},'"[version]([buildNumber|versionCode])"'),", which in this case would be ",Object(r.b)("inlineCode",{parentName:"p"},'"1.0.0(1)"'),"."),Object(r.b)("p",null,"This policy is great for projects that contain custom native code and that update the native version numbers (",Object(r.b)("inlineCode",{parentName:"p"},'"buildNumber"'),"for iOS and ",Object(r.b)("inlineCode",{parentName:"p"},'"versionCode"')," for Android) for each build. To submit an app, the app stores require an updated native version number for each submitted build, which makes this policy convenient for projects who use the Play Store's Internal Test Track and the App Store's TestFlight distribution tools."),Object(r.b)("p",null,"It's important to know that this policy does require the developer to manage the native version numbers manually between each build."),Object(r.b)("p",null,"Also, if you select a different native version between iOS and Android, you'll end up with builds and updates with separate runtime versions. When you publish an update, EAS CLI will detect that two updates are needed, and it will create two updates with the required runtime versions and publish them separately."),Object(r.b)("h3",{id:"custom-runtimeversion"},"Custom ",Object(r.b)("inlineCode",{parentName:"h3"},'"runtimeVersion"')),Object(r.b)("p",null,"You can also set a custom runtime version that meets the ",Object(r.b)("a",{parentName:"p",href:"/../../../../../../versions/latest/config/app/#runtimeversion"},"runtime version formatting requirements"),":"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "expo": {\n    "runtimeVersion": "1.0.0"\n  }\n}\n')),Object(r.b)("p",null,"This option is good for developers who want to manage the runtime version manually, separately from any other version numbers present in a project's app config. It gives the developer complete control over which updates are compatible with which builds."),Object(r.b)("h3",{id:"platform-specific-runtimeversion"},"Platform specific ",Object(r.b)("inlineCode",{parentName:"h3"},'"runtimeVersion"')),Object(r.b)("p",null,"You can also set a runtime version for a specific platform:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "expo": {\n    "android": {\n        "runtimeVersion": "1.0.0"\n    }\n  }\n}\n')),Object(r.b)("p",null,"When both a top level runtime and a platform specific runtime are set, the platform specific one takes precedence."),Object(r.b)("h2",{id:"avoiding-crashes-with-incompatible-updates"},"Avoiding crashes with incompatible updates"),Object(r.b)("p",null,"The main issue that can arise when publishing updates is that the update could rely on native code that the build it's running on does not support. For instance, imagine we made a build with a runtime version of ",Object(r.b)("inlineCode",{parentName:"p"},'"1.0.0"'),". Then, we submitted that build to the app stores and released it to the public."),Object(r.b)("p",null,"Later on, imagine that we developed an update that relied on a newly installed native library, like the ",Object(r.b)("inlineCode",{parentName:"p"},"expo-in-app-purchases")," library, and we did not update the ",Object(r.b)("inlineCode",{parentName:"p"},'"runtimeVersion"')," property, so that it is still ",Object(r.b)("inlineCode",{parentName:"p"},'"1.0.0"'),". If we published an update, the builds with the ",Object(r.b)("inlineCode",{parentName:"p"},'"runtimeVersion"')," of ",Object(r.b)("inlineCode",{parentName:"p"},'"1.0.0"')," would think the incoming update with the same runtime version was compatible and it would attempt to load the update. Since the update would make calls to code that does not exist inside the build, the app would crash."),Object(r.b)("p",null,"There are a few ways to avoid crashes like this:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Whenever we install or update native code, iterate the ",Object(r.b)("inlineCode",{parentName:"li"},'"runtimeVersion"')," property in the project's app config (",Object(r.b)("strong",{parentName:"li"},"app.json"),"/",Object(r.b)("strong",{parentName:"li"},"app.config.js"),")."),Object(r.b)("li",{parentName:"ul"},'Create a preview build of your app and load it on a test device. Then, publish the update to the "preview" branch to make sure it works as expected before publishing it to the project\'s production branch.')),Object(r.b)("p",null,"If this error does occur, then you can republish a previous known-good update, then ask users to delete the app and reinstall it."),Object(r.b)("p",null,"In the future, the ",Object(r.b)("inlineCode",{parentName:"p"},"expo-updates")," library will prevent many instances of this from crashing the app. If we can detect this particular issue, we'll automatically roll back to a previous update instead of loading the bad update."))}u.isMDXComponent=!0},"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var i=n("q1tI"),a=n.n(i);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),c=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):p(p({},t),e)),n},u=function(e){var t=c(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=a.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(n),b=i,h=u["".concat(o,".").concat(b)]||u[b]||d[b]||r;return n?a.a.createElement(h,p(p({ref:t},l),{},{components:n})):a.a.createElement(h,p({ref:t},l))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"===typeof e||i){var r=n.length,o=new Array(r);o[0]=b;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"===typeof e?e:i,o[1]=p;for(var l=2;l<r;l++)o[l]=n[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},KiYJ:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var i=n("cpVT"),a=n("3zh3"),r=(n("q1tI"),n("AeFk"));function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){Object(i.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e){var t=e.alt,n=e.src,i=e.style,o=e.containerStyle;return Object(r.c)("div",{style:p({textAlign:"center",backgroundColor:a.theme.background.secondary,paddingTop:10,paddingBottom:10,marginTop:20,marginBottom:20},o)},Object(r.c)("img",{src:n,alt:t,style:i}))}},cpVT:function(e,t,n){"use strict";function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}n.d(t,"a",(function(){return i}))},"qM/2":function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/eas-update/runtime-versions",function(){return n("0L4s")}])}},[["qM/2",1,0,2,3]]]);