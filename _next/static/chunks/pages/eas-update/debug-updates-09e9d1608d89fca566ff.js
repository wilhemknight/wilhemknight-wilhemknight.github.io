_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[108],{"5B0E":function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/eas-update/debug-updates",function(){return n("Pp/U")}])},"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n("q1tI"),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),c=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"===typeof e?e(t):p(p({},t),e)),n},u=function(e){var t=c(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(n),b=a,h=u["".concat(o,".").concat(b)]||u[b]||d[b]||r;return n?i.a.createElement(h,p(p({ref:t},l),{},{components:n})):i.a.createElement(h,p({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"===typeof e||a){var r=n.length,o=new Array(r);o[0]=b;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"===typeof e?e:a,o[1]=p;for(var l=2;l<r;l++)o[l]=n[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},KiYJ:function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var a=n("cpVT"),i=n("3zh3"),r=(n("q1tI"),n("AeFk"));function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){Object(a.a)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e){var t=e.alt,n=e.src,a=e.style,o=e.containerStyle;return Object(r.c)("div",{style:p({textAlign:"center",backgroundColor:i.theme.background.secondary,paddingTop:10,paddingBottom:10,marginTop:20,marginBottom:20},o)},Object(r.c)("img",{src:n,alt:t,style:a}))}},"Pp/U":function(e,t,n){"use strict";n.r(t),n.d(t,"meta",(function(){return s})),n.d(t,"headings",(function(){return l})),n.d(t,"default",(function(){return u}));var a=n("HALo"),i=n("dhJC"),r=(n("q1tI"),n("7ljp")),o=n("KiYJ"),p=["components"],s={title:"Debugging guide"},l=[{depth:2,type:"text",title:"expo-updates configuration"},{depth:3,type:"text",title:"Verifying app configuration"},{depth:3,type:"text",title:"Inspecting expo-updates configuration after prebuild"},{depth:2,type:"text",title:"EAS Update configuration"},{depth:3,type:"text",title:"1. Verify a channel"},{depth:4,type:"text",title:"Configuring channels"},{depth:4,type:"text",title:"Inspecting channels on EAS"},{depth:3,type:"text",title:"2. Verify the channel/branch mapping"},{depth:3,type:"text",title:"3. Verify the update"},{depth:3,type:"text",title:"Verify the update command"},{depth:3,type:"text",title:"Viewing deployments"},{depth:2,type:"text",title:"Debugging"},{depth:3,type:"text",title:"In-app debugging"},{depth:3,type:"text",title:"Viewing network requests"},{depth:3,type:"text",title:"Inspecting a build manually"},{depth:3,type:"text",title:"Inspecting the latest update locally"},{depth:3,type:"text",title:"Inspecting manifests manually"},{depth:3,type:"text",title:"Viewing all assets included in an update"},{depth:2,type:"text",title:"Mitigation steps"},{depth:3,type:"text",title:"Re-publishing a previous update"},{depth:2,type:"text",title:"Wrap up"}],c={meta:s,headings:l};function u(e){var t=e.components,n=Object(i.a)(e,p);return Object(r.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"It's important to tell the current state of our app at any given time. We built EAS Update with this in mind. Once we know which updates are running on which builds, we can make changes so that our apps are in the state we expect and desire. This guide sets out to show how we can verify our EAS Update and expo-updates configuration, so that we can find the source of problems like an app not showing a published update."),Object(r.b)("h2",{id:"expo-updates-configuration"},"expo-updates configuration"),Object(r.b)("p",null,"The expo-updates library runs inside an end-user's app and makes requests to an update server to get the latest update."),Object(r.b)("h3",{id:"verifying-app-configuration"},"Verifying app configuration"),Object(r.b)("p",null,"When we set up EAS Update, we likely ran ",Object(r.b)("inlineCode",{parentName:"p"},"eas update:configure")," to configure expo-updates to work with EAS Update. This command makes changes to our app config (",Object(r.b)("strong",{parentName:"p"},"app.json"),"/",Object(r.b)("strong",{parentName:"p"},"app.config.js"),"). Here are the fields we'd expect to see:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"runtimeVersion")," should be set. By default it is ",Object(r.b)("inlineCode",{parentName:"li"},'{ "policy": "sdkVersion" }'),". If our project has ",Object(r.b)("strong",{parentName:"li"},"android")," and ",Object(r.b)("strong",{parentName:"li"},"ios")," directories, we'll have to set the ",Object(r.b)("inlineCode",{parentName:"li"},"runtimeVersion")," manually."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"updates.url")," should be a value like ",Object(r.b)("inlineCode",{parentName:"li"},"https://u.expo.dev/your-project-id"),", where ",Object(r.b)("inlineCode",{parentName:"li"},"your-project-id")," matches the ID of our project. We can see this ID on ",Object(r.b)("a",{parentName:"li",href:"https://expo.dev/accounts/%5Baccount%5D/projects/%5Bproject%5D"},"our website"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"updates.enabled")," should not be ",Object(r.b)("inlineCode",{parentName:"li"},"false"),". It's ",Object(r.b)("inlineCode",{parentName:"li"},"true")," by default if it is not specified.")),Object(r.b)("p",null,"Finally, make sure that ",Object(r.b)("inlineCode",{parentName:"p"},"expo-updates")," is included in ",Object(r.b)("strong",{parentName:"p"},"package.json"),". If it's not, run:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"expo install expo-updates\n")),Object(r.b)("h3",{id:"inspecting-expo-updates-configuration-after-prebuild"},"Inspecting expo-updates configuration after prebuild"),Object(r.b)("p",null,"Whenever we run ",Object(r.b)("inlineCode",{parentName:"p"},"eas build"),", the ",Object(r.b)("inlineCode",{parentName:"p"},"expo prebuild")," command is run on our project on EAS' servers to unpack the ",Object(r.b)("strong",{parentName:"p"},"android")," and ",Object(r.b)("strong",{parentName:"p"},"ios")," directories that contain native files. This make it so EAS Build can build any project, whether it includes the native files or not."),Object(r.b)("p",null,"If our project does not have ",Object(r.b)("strong",{parentName:"p"},"android")," or ",Object(r.b)("strong",{parentName:"p"},"ios")," directories, we can make commit any existing changes, then run ",Object(r.b)("inlineCode",{parentName:"p"},"expo prebuild")," to inspect the project state that EAS Build will act on. After running this, look for the following files: ",Object(r.b)("strong",{parentName:"p"},"android/app/src/main/AndroidManifest.xml")," and ",Object(r.b)("strong",{parentName:"p"},"ios/your-project-name/Supporting/Expo.plist"),"."),Object(r.b)("p",null,"In each, we expect to see configuration for the EAS Update URL and the runtime version. Here are properties we'd expect to see in each file:"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"AndroidManifest.xml")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-xml"},'...\n<meta-data android:name="expo.modules.updates.EXPO_RUNTIME_VERSION" android:value="your-runtime-version-here"/>\n<meta-data android:name="expo.modules.updates.EXPO_UPDATE_URL" android:value="https://u.expo.dev/your-project-id-here"/>\n...\n')),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Expo.plist")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-xml"},"...\n<key>EXUpdatesRuntimeVersion</key>\n<string>your-runtime-version-here</string>\n<key>EXUpdatesURL</key>\n<string>https://u.expo.dev/your-project-id-here</string>\n...\n")),Object(r.b)("h2",{id:"eas-update-configuration"},"EAS Update configuration"),Object(r.b)("p",null,"To debug the state of EAS Update in our project, we'll need to look at multiple spots in the system. Below is a diagram of how EAS Update works and the spots that are useful to inspect when finding the root cause of an issue. In the sections following, we'll inspect and verify these spots and more."),Object(r.b)(o.a,{alt:"Map of debugging spots",src:"/static/images/eas-update/debug-map.png",mdxType:"ImageSpotlight"}),Object(r.b)("h3",{id:"1-verify-a-channel"},"1. Verify a channel"),Object(r.b)("p",null,"Builds have a property named ",Object(r.b)("em",{parentName:"p"},"channel"),', which EAS Update uses to link to a branch. A channel is often given to multiple platform-specific builds. For instance, we might have an Android build and an iOS build, both with a channel named "production".'),Object(r.b)("h4",{id:"configuring-channels"},"Configuring channels"),Object(r.b)("p",null,"To verify that a build has a specific channel, make sure that in ",Object(r.b)("strong",{parentName:"p"},"eas.json"),", there is a channel property:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-json"},'{\n  "build": {\n    "preview": {\n      "distribtuion": "internal",\n      "channel": "preview"\n    },\n    "production": {\n      "channel": "production"\n    }\n  }\n}\n')),Object(r.b)("p",null,"Then, we can run a command like ",Object(r.b)("inlineCode",{parentName:"p"},"eas build --profile preview"),' to create a build with a channel named "preview".'),Object(r.b)("h4",{id:"inspecting-channels-on-eas"},"Inspecting channels on EAS"),Object(r.b)("p",null,"Once a build has a channel name, we can make sure that EAS' servers know about the channel by running the following commands:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"eas channel:list\n")),Object(r.b)("p",null,"or"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"eas channel:view [channel-name]\n\n# example\n\neas channel:view production\n")),Object(r.b)("p",null,"We'd expect the output of these commands to display the same channel name that our build has. If it's not there, we can create the channel on EAS' servers with:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"eas channel:create [channel-name]\n\n# example\n\neas channel:create production\n")),Object(r.b)("h3",{id:"2-verify-the-channelbranch-mapping"},"2. Verify the channel/branch mapping"),Object(r.b)("p",null,"There is a link that is defined by the developer between a channel and a branch. When a channel and branch are linked, an app with a channel will get the most recent compatible update on the linked branch."),Object(r.b)("p",null,"To verify which branch is linked to a channel, we can run:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"eas channel:view [channel-name]\n\n# example\n\neas channel:view production\n")),Object(r.b)("p",null,"If the channel is not linked to the branch we expect, we can change the link with:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"eas channel:edit [channel-name] --branch [branch-name]\n\n# example\n\neas channel:edit production --branch release-1.0\n")),Object(r.b)("h3",{id:"3-verify-the-update"},"3. Verify the update"),Object(r.b)("p",null,"Every branch contains a list of updates. When a build makes a call for an update, we find the channel of the build, then the branch linked to that channel. Once the branch is found, EAS will return the most recent compatible update on that branch. A build and an update are compatible when they share the same runtime version and platform."),Object(r.b)("p",null,"To inspect which updates are on a branch, we can run:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"eas branch:view [branch-name]\n\n# example\n\neas branch:view production\n")),Object(r.b)("p",null,"The output of this command will show us a list of updates and their runtime versions and platforms. From this list, we should be able to figure out which update should apply to a given build, by matching the build's runtime version and platform to update's runtime version and platform. The most recent update that is compatible will be available for a build to download and execute."),Object(r.b)("h3",{id:"verify-the-update-command"},"Verify the update command"),Object(r.b)("p",null,"To create and publish an update, we can run the following command:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"eas update\n")),Object(r.b)("p",null,"After publishing, the output will display the branch and the runtime version. This info can help us verify that we're creating an update with the configuration we expect."),Object(r.b)("h3",{id:"viewing-deployments"},"Viewing deployments"),Object(r.b)("p",null,"If we've made builds and updates with EAS, we can view the state of our project on our website on our project's deployments tab. We use the term ",Object(r.b)("em",{parentName:"p"},"deployments")," to refer to the entire system of builds and their updates. The system includes builds, channels, branches, updates, runtime versions, and platforms."),Object(r.b)("p",null,"The EAS website has a page that shows the current state of our apps. We can view it at ",Object(r.b)("a",{parentName:"p",href:"https://expo.dev/accounts/%5Baccount%5D/projects/%5Bproject%5D/deployments"},"https://expo.dev/accounts/[account]/projects/[project]/deployments"),"."),Object(r.b)("h2",{id:"debugging"},"Debugging"),Object(r.b)("p",null,"After verifying expo-updates and EAS Update configurations, we can move on to debugging how our project is interacting with updates."),Object(r.b)("h3",{id:"in-app-debugging"},"In-app debugging"),Object(r.b)("p",null,"The expo-updates library exports a variety of functions to interact with updates once the app is already running. In certain cases, making a call to fetch an update and seeing an error message can help us narrow down the root cause."),Object(r.b)("p",null,"We can write the following code then make a simulator build of our project to see if there are errors fetching updates:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-jsx"},"import { View, Button } from 'react-native';\nimport * as Updates from 'expo-updates';\n\nfunction App() {\n  async function onFetchUpdateAsync() {\n    try {\n      const update = await Updates.checkForUpdateAsync();\n\n      if (update.isAvailable) {\n        await Updates.fetchUpdateAsync();\n        await Updates.reloadAsync();\n      }\n    } catch (error) {\n      alert(`Error fetching latest Expo update: ${error}`);\n    }\n  }\n\n  return (\n    <View>\n      <Button title=\"Fetch update\" onPress={onFetchUpdateAsync} />\n    </View>\n  );\n}\n")),Object(r.b)("h3",{id:"viewing-network-requests"},"Viewing network requests"),Object(r.b)("p",null,"Another way to identify the root cause of an issue is to look at the network requests that the app is making to EAS servers, then viewing the responses. We recommend using a progam like ",Object(r.b)("a",{parentName:"p",href:"https://proxyman.io/"},"Proxyman")," or ",Object(r.b)("a",{parentName:"p",href:"https://www.charlesproxy.com/"},"Charles Proxy")," to watch network requests from our app."),Object(r.b)("p",null,"With either program, we'll need to follow their instructions for installing an SSL certificate, so that the program can decode HTTPS requests. Once that's set up in a simulator or on an actual device, we can open our app and watch requests."),Object(r.b)("p",null,"The requests we're interested in are from ",Object(r.b)("a",{parentName:"p",href:"https://u.expo.dev"},"https://u.expo.dev")," and from ",Object(r.b)("a",{parentName:"p",href:"https://assets.eascdn.net."},"https://assets.eascdn.net.")," Responses from ",Object(r.b)("a",{parentName:"p",href:"https://u.expo.dev"},"https://u.expo.dev")," will contain an update manifest, which specifies which assets the app will need to fetch to run the update. Responses from ",Object(r.b)("a",{parentName:"p",href:"https://assets.eascdn.net"},"https://assets.eascdn.net")," will contain assets, like images, font files, etc that are required for the update to run."),Object(r.b)("p",null,"When inspecting the request to ",Object(r.b)("a",{parentName:"p",href:"https://u.expo.dev"},"https://u.expo.dev"),", we can look for the following request headers:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Expo-Runtime-Version"),": this should make the runtime version we made our build and update with."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"expo-channel-name"),": this should be the channel name specified in the ",Object(r.b)("strong",{parentName:"li"},"eas.json")," build profile."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Expo-Platform"),': this should be either "android" or "ios".')),Object(r.b)("p",null,"As for all requests, we expect to see either ",Object(r.b)("inlineCode",{parentName:"p"},"200")," response codes, or ",Object(r.b)("inlineCode",{parentName:"p"},"304")," if nothing has changed."),Object(r.b)("p",null,"Below is a screenshot showing the request of a successful update manfiest request:"),Object(r.b)(o.a,{alt:"Successful manifest request",src:"/static/images/eas-update/network-request.png",mdxType:"ImageSpotlight"}),Object(r.b)("h3",{id:"inspecting-a-build-manually"},"Inspecting a build manually"),Object(r.b)("p",null,"When building a project into an app, there can be multiple steps that alter the output of ",Object(r.b)("inlineCode",{parentName:"p"},"expo prebuild"),". After making a build, it is possible to open the build's contents and inspect native files to see its final configuration."),Object(r.b)("p",null,"Here are the steps for inspecting an iOS simulator build on MacOS:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Create an iOS simulator build of the app using EAS Build. This is done by adding ",Object(r.b)("inlineCode",{parentName:"li"},'"ios": { "simulator": true }')," to a build profile."),Object(r.b)("li",{parentName:"ol"},"Once the build is finished, download the result and unzip it."),Object(r.b)("li",{parentName:"ol"},'Then, right click on the app and select "Show Package Contents".'),Object(r.b)("li",{parentName:"ol"},"From there, we can inspect the ",Object(r.b)("strong",{parentName:"li"},"Expo.plist")," file.")),Object(r.b)("p",null,"Inside the ",Object(r.b)("strong",{parentName:"p"},"Expo.plist")," file, we expect to see the following configurations:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-xml"},"...\n<key>EXUpdatesRequestHeaders</key>\n<dict>\n  <key>expo-channel-name</key>\n  <string>your-channel-name</string>\n</dict>\n<key>EXUpdatesRuntimeVersion</key>\n<string>your-runtime-version</string>\n<key>EXUpdatesURL</key>\n<string>https://u.expo.dev/your-project-id</string>\n...\n")),Object(r.b)("h3",{id:"inspecting-the-latest-update-locally"},"Inspecting the latest update locally"),Object(r.b)("p",null,"When we publish an update with EAS Update, it creates a ",Object(r.b)("strong",{parentName:"p"},"/dist")," folder in the root of our project locally, which includes the assets that were uploaded as a part of the update."),Object(r.b)(o.a,{alt:"Dist directory",src:"/static/images/eas-update/dist.png",mdxType:"ImageSpotlight"}),Object(r.b)("h3",{id:"inspecting-manifests-manually"},"Inspecting manifests manually"),Object(r.b)("p",null,"When an update is published with EAS Update, we create a manifest that end-user app's request. The manifest has information like which assets and versions are needed for an update to load. We can inspect the manifest by going to a specific URL in a browser or by using ",Object(r.b)("inlineCode",{parentName:"p"},"curl"),"."),Object(r.b)("p",null,"Inside our project's app config (",Object(r.b)("strong",{parentName:"p"},"app.json"),"/",Object(r.b)("strong",{parentName:"p"},"app.config.json"),"), the URL we can GET is under ",Object(r.b)("inlineCode",{parentName:"p"},"updates.url"),"."),Object(r.b)("p",null,"This ",Object(r.b)("inlineCode",{parentName:"p"},"url")," is EAS' \"",Object(r.b)("a",{parentName:"p",href:"https://u.expo.dev%22"},'https://u.expo.dev"')," domain, followed by the project's ID on EAS' servers. If we go to the URL directly, we'll see an error about missing a header. We can view a manifest by adding three query parameters to the URL: ",Object(r.b)("inlineCode",{parentName:"p"},"runtime-version"),", ",Object(r.b)("inlineCode",{parentName:"p"},"channel-name"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"platform"),". If we published an update with a runtime version of ",Object(r.b)("inlineCode",{parentName:"p"},"1.0.0"),", a channel of ",Object(r.b)("inlineCode",{parentName:"p"},"production")," and a platform of ",Object(r.b)("inlineCode",{parentName:"p"},"android"),", the full URL you could visit would be similar to this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"https://u.expo.dev/your-project-id?runtime-version=1.0.0&channel-name=production&platform=android\n")),Object(r.b)("h3",{id:"viewing-all-assets-included-in-an-update"},"Viewing all assets included in an update"),Object(r.b)("p",null,"It may be helpful to see which assets are included in our update bundle. We can see a list of named assets by running:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"expo export --experimental-bundle\n")),Object(r.b)("h2",{id:"mitigation-steps"},"Mitigation steps"),Object(r.b)("p",null,"Once we've found the root cause of the issue, there are various mitigation steps we might want to take. One of the most common problems is pushing an update that has a bug inside it. When this happens, we can re-publish a previous update to resolve the issue."),Object(r.b)("h3",{id:"re-publishing-a-previous-update"},"Re-publishing a previous update"),Object(r.b)("p",null,'The fastest way to "undo" a bad publish is to re-publish a known good update. Imagine we have a branch with two updates:'),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},'branch: "production"\nupdates: [\n  update 2 (id: xyz2) "fixes typo"     // bad update\n  update 1 (id: abc1) "updates color"  // good update\n]\n')),Object(r.b)("p",null,'If "update 2" turned out to be a bad update, we can re-publish "update 1" with a command like this:'),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},"eas update --branch [branch-name] --republish --group [update-group-id]\n\n# Example\neas update --branch production --republish --group abc1\n")),Object(r.b)("p",null,"The example command above would result in a branch that now appears like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-bash"},'branch: "production"\nupdates: [\n  update 3 (id: def3) "updates color"  // re-publish of update 1 (id: abc1)\n  update 2 (id: xyz2) "fixes typo"     // bad update\n  update 1 (id: abc1) "updates color"  // good update\n]\n')),Object(r.b)("p",null,'Since "update 3" is now the most recent update on the "production" branch, all users who query for an update in the future will receive "update 3" instead of the bad update, "update 2".'),Object(r.b)("p",null,"While this will prevent all new users from seeing the bad update, users who've already received the bad update will run it until they can download the latest update. Since mobile networks are not always able to download the most recent update, sometimes users may run a bad update for a long time. When viewing error logs for our app, it's normal to see a lingering long tail of errors as our users' apps get the most recent update or build. We'll know we solved the bug when we see the error rate decline dramatically; however, it likely will not disappear completely if we have a diverse user base across many locations and mobile networks."),Object(r.b)("h2",{id:"wrap-up"},"Wrap up"),Object(r.b)("p",null,"Still having issues with EAS Update? Provide us with a reproduction repo in our ",Object(r.b)("a",{parentName:"p",href:"https://forums.expo.dev/c/expo-application-services/56"},"forums"),". Also, feel free to ask in the #updates channel on our ",Object(r.b)("a",{parentName:"p",href:"https://chat.expo.dev/"},"community Discord"),", or ",Object(r.b)("a",{parentName:"p",href:"https://expo.dev/contact"},"contact us")," directly."))}u.isMDXComponent=!0},cpVT:function(e,t,n){"use strict";function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}n.d(t,"a",(function(){return a}))}},[["5B0E",1,0,2,3]]]);