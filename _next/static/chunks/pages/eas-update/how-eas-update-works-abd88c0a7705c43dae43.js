_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[117],{"2AdR":function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/eas-update/how-eas-update-works",function(){return a("THH5")}])},"7ljp":function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return b}));var n=a("q1tI"),i=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var c=i.a.createContext({}),u=function(e){var t=i.a.useContext(c),a=t;return e&&(a="function"===typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=u(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},h=i.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,r=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(a),h=n,b=p["".concat(r,".").concat(h)]||p[h]||d[h]||o;return a?i.a.createElement(b,l(l({ref:t},c),{},{components:a})):i.a.createElement(b,l({ref:t},c))}));function b(e,t){var a=arguments,n=t&&t.mdxType;if("string"===typeof e||n){var o=a.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"===typeof e?e:n,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,a)}h.displayName="MDXCreateElement"},KiYJ:function(e,t,a){"use strict";a.d(t,"a",(function(){return s}));var n=a("cpVT"),i=a("3zh3"),o=(a("q1tI"),a("AeFk"));function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){Object(n.a)(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e){var t=e.alt,a=e.src,n=e.style,r=e.containerStyle;return Object(o.c)("div",{style:l({textAlign:"center",backgroundColor:i.theme.background.secondary,paddingTop:10,paddingBottom:10,marginTop:20,marginBottom:20},r)},Object(o.c)("img",{src:a,alt:t,style:n}))}},THH5:function(e,t,a){"use strict";a.r(t),a.d(t,"meta",(function(){return s})),a.d(t,"headings",(function(){return c})),a.d(t,"default",(function(){return p}));var n=a("HALo"),i=a("dhJC"),o=(a("q1tI"),a("7ljp")),r=a("KiYJ"),l=["components"],s={title:"How EAS Update works"},c=[{depth:2,type:"text",title:"Conceptual overview"},{depth:2,type:"text",title:"Practical overview"},{depth:2,type:"text",title:"Wrap up"}],u={meta:s,headings:c};function p(e){var t=e.components,a=Object(i.a)(e,l);return Object(o.b)("wrapper",Object(n.a)({},u,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"EAS Update is a service that allows you to deliver small bug fixes and updates to your users immediately as you work on your next app store release. Making an update available to builds involves creating a link between a build and an update."),Object(o.b)("p",null,"To create a link between a build and an update, we have to make sure the update can run on the build. We also want to make sure we can create a deployment process so that we can expose certain updates to certain builds when we're ready."),Object(o.b)("p",null,"To illustrate how builds and updates interact, take a look at the following diagram:"),Object(o.b)(r.a,{alt:"Native and update layers diagram",src:"/static/images/eas-update/layers.png",mdxType:"ImageSpotlight"}),Object(o.b)("p",null,"Builds can be thought of as two layers: a native layer that's built into the app's binary, and an update layer, that is swappable with other compatible updates. This separation allows us to ship bug fixes to builds as long as the update with the bug fix can run on the native layer inside the build."),Object(o.b)("p",null,"To make sure the update can run on the build, we have to set a variety of properties so that we can be sure our builds can run our updates. This starts when we create a build of our project."),Object(o.b)("h2",{id:"conceptual-overview"},"Conceptual overview"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Distributing builds")),Object(o.b)("p",null,"When we're ready to create a build of our Expo project, we can run ",Object(o.b)("inlineCode",{parentName:"p"},"eas build")," to create a build. During the build, the process will include some properties inside the build that are important for updates. They are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Channel: The channel is a name we can give to multiple builds to identify them easily. It is defined in ",Object(o.b)("strong",{parentName:"li"},"eas.json"),'. For instance, we may have an Android and an iOS build with a channel named "production", while we have another pair of builds with a channel named "staging". Then, we can distribute the builds with the "production" channel to the public app stores, while keeping the "staging" builds on the Play Store Internal Track and TestFlight. Later when we publish an update, we can make it available to the builds with the "staging" channel first; then once we test our changes, we can make the update available to the builds with the "production" channel.'),Object(o.b)("li",{parentName:"ul"},"Runtime version: The runtime version describes the JS\u2013native interface defined by the native code layer that runs our app's update layer. It is defined in a project's app config (",Object(o.b)("strong",{parentName:"li"},"app.json"),"/",Object(o.b)("strong",{parentName:"li"},"app.config.js"),"). Whenever we make changes to our native code that change our app's JS\u2013native interface, we'll need to update the runtime version. ",Object(o.b)("a",{parentName:"li",href:"/../../../../../../eas-update/runtime-versions"},"Learn more.")),Object(o.b)("li",{parentName:"ul"},'Platform: Every build has a platform, such as "Android" or "iOS".')),Object(o.b)("p",null,'If we made two sets of builds with the channels named "staging" and "production", we could distribute builds to four different places:'),Object(o.b)(r.a,{alt:"Build types diagram",src:"/static/images/eas-update/builds.png",mdxType:"ImageSpotlight"}),Object(o.b)("p",null,"This diagram is just an example of how you could create builds and name their channels, and where you could put those builds. Ultimately it's up to you which channel names you set and where you put those builds."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Publishing an update")),Object(o.b)("p",null,"Once we've created builds, we can change the update layer of our project by publishing an update. For example, we could change some text inside ",Object(o.b)("strong",{parentName:"p"},"App.js"),", then we could publish that change as an update."),Object(o.b)("p",null,"To publish an update, we can run ",Object(o.b)("inlineCode",{parentName:"p"},"eas update --auto"),". This command will create a local update bundle inside the ",Object(o.b)("strong",{parentName:"p"},"./dist")," folder in our project. Once it's created an update bundle, it will upload that bundle to EAS' servers, in a database object named a ",Object(o.b)("em",{parentName:"p"},"branch"),". A branch has a name, and contains a list of updates, where the most recent update is the active update on the branch. We can think of EAS branches just like Git branches. Just as Git branches contain a list of commits, EAS branches contain a list of updates."),Object(o.b)(r.a,{alt:"Branches with its most recent update pointed out as the active one",src:"/static/images/eas-update/branch.png",mdxType:"ImageSpotlight"}),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Matching updates and builds")),Object(o.b)("p",null,"Like builds, every update on a branch includes a target runtime version and target platform. With these fields, we can make sure that an update will run on a build with something called an ",Object(o.b)("em",{parentName:"p"},"update policy"),". EAS' update policy is as follows:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The platform of the build and the target platform of an update must match exactly."),Object(o.b)("li",{parentName:"ul"},"The runtime version of the build and the target runtime version of an update must match exactly."),Object(o.b)("li",{parentName:"ul"},"A channel can be linked to any branch. By default, a channel is linked to a branch of the same name.")),Object(o.b)("p",null,'Let\'s focus on that last point. Every build has a channel, and we, as developers, can link that channel to any branch, which will make its most recent compatible update available on the branch to the linked channel. To simplify this linking, by default we auto-link channels to branches of the same name. For instance, if we created builds with the channel named "production", we could publish updates to a branch named "production" and our builds would get the updates from the branch named "production", even though we did not manually link anything.'),Object(o.b)(r.a,{alt:'Channel "production" linked to branch "production" by default',src:"/static/images/eas-update/default-link.png",mdxType:"ImageSpotlight"}),Object(o.b)("p",null,'This default linking works great if you have a deployment process where you have multiple consistent Git and EAS branches. For instance, we could have a "production" branch and a "staging" branch, both on Git and on EAS. Paired with a ',Object(o.b)("a",{parentName:"p",href:"/../../../../../../eas-update/github-actions"},"GitHub Action"),', we could make it so that every time a commit is pushed to the "staging" Git branch, we publish to the "staging" EAS Update branch, which would make that update apply to all our builds with the "staging" channel. Once we tested changes on the staging builds, then we could merge the "staging" Git branch into the "production" Git branch, which would publish an update on the "production" EAS Update branch. Finally, the latest update on the "production" EAS Update branch would apply to builds with the "production" channel.'),Object(o.b)("p",null,"This flow makes it so that we can push to GitHub, then see our builds update without any other interventions."),Object(o.b)("p",null,'While this flow works for many developers, there\'s another flow we can accomplish since we have the ability to change the link between channels and branches. Imagine we name our branches like "version-1.0", "version-2.0", and "version-3.0". We could link the "version-1.0" EAS Update branch to the "production" channel, to make it available to our "production" builds. We could also link the "version-2.0" EAS Update branch to the "staging" channel to make it available to testers. Finally, we could make a "version-3.0" EAS Update branch that is not linked to any builds yet, that only developers are testing with a development build.'),Object(o.b)(r.a,{alt:'Channel "production" linked to branch "version-1.0", channel "staging" linked to branch "version-2.0"',src:"/static/images/eas-update/custom-link-1.png",mdxType:"ImageSpotlight"}),Object(o.b)("p",null,'Once testers verify that the update on the "version-2.0" EAS Update branch is ready for production, we can update the "production" channel so that it\'s linked to the "version-2.0" branch. To accomplish this, we could run:'),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-bash"},"eas channel:edit production --branch version-2.0\n")),Object(o.b)(r.a,{alt:'Channel "production" linked to branch "version-2.0", channel "staging" linked to branch "version-2.0"',src:"/static/images/eas-update/custom-link-2.png",mdxType:"ImageSpotlight"}),Object(o.b)("p",null,'After this state, we\'d be ready to start testing the "version-3.0" EAS Update branch. Similarly to the last step, we could link the "staging" channel to the "version-3.0" EAS Update branch with this command:'),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-bash"},"eas channel:edit staging --branch version-3.0\n")),Object(o.b)(r.a,{alt:'Channel "production" linked to branch "version-2.0", channel "staging" linked to branch "version-3.0"',src:"/static/images/eas-update/custom-link-3.png",mdxType:"ImageSpotlight"}),Object(o.b)("h2",{id:"practical-overview"},"Practical overview"),Object(o.b)("p",null,"Now that we're familiar with the core concepts of EAS Update, let's talk about how this process occurs."),Object(o.b)("p",null,"When an Expo project that includes ",Object(o.b)("inlineCode",{parentName:"p"},"expo-updates")," is built the included native Android and iOS code is responsible for managing, fetching, parsing, and validating updates."),Object(o.b)("p",null,"When the library checks for updates and when it downloads them is ",Object(o.b)("a",{parentName:"p",href:"/../versions/latest/config/app/#updates"},"configurable"),". By default the library will check for an update when it is opened. If an update newer than the current running update is found, it will download and run the newer update. If the library does not find a newer update, it will instead run the newest downloaded update, falling back to the update that was embedded inside the app at build time if none have been downloaded."),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"expo-updates")," downloads updates in two phases. First, it downloads the most recent update ",Object(o.b)("em",{parentName:"p"},"manifest"),", which contains information about the update including a list of assets (images, JavaScript bundles, font files, etc...) that are required to run the update. Second, the library downloads the assets specified in the manifest that is has not yet downloaded from prior updates. For instance, if an update contains a new image, the library will download the new image asset before running the update. To help end-users get updates quickly and reliably, updates should be kept as small as possible."),Object(o.b)("p",null,"If the library is able to download the manifest (phase 1) and all the required assets (phase 2) before the ",Object(o.b)("inlineCode",{parentName:"p"},"fallbackToCacheTimeout")," setting, then the new update will run immediately upon launch. If the library is not able to fetch the manifest and assets within ",Object(o.b)("inlineCode",{parentName:"p"},"fallbackToCacheTimeout"),", it will continue to download the new update in the background and will run it upon the next launch."),Object(o.b)(r.a,{alt:"Update download timeline",src:"/static/images/eas-update/process.png",mdxType:"ImageSpotlight"}),Object(o.b)("h2",{id:"wrap-up"},"Wrap up"),Object(o.b)("p",null,"With EAS Update, we can quickly deliver small, critical bug fixes to our users and give users the best experience possible. This is set up with a build's runtime version, platform, and channel. With these three constraints, we can make an update available to a specific group of builds. This allows us to test our changes before going to production within a deployment process. Depending on how we set up our deployment process, we can optimize for speed. We can also optimize our deployments to be as safe a bug-free as possible. The deployment possibilities are vast and can match nearly any release process you prefer."))}p.isMDXComponent=!0},cpVT:function(e,t,a){"use strict";function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}a.d(t,"a",(function(){return n}))}},[["2AdR",1,0,2,3]]]);